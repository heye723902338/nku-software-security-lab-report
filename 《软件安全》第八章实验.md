# 《软件安全》第八章实验

**姓名：何叶  学号:2313487  班级：范玲玲班**

## 实验名称：

## 程序插桩及Hook实验

[TOC]

## 一、实验要求

复现实验一，基于Windows MyPinTool或在Kali中复现malloctrace这个PinTool，理解Pin插桩工具的核心步骤和相关API，关注malloc和free函数的输入输出信息。

## 二、实验过程

### （一）、安装pin

#### 1.在windows中下载解压pin

![image-20250507083833673](C:\Users\he'ye\AppData\Roaming\Typora\typora-user-images\image-20250507083833673.png)

#### 2.复制到kali虚拟机中

![image-20250507083937307](C:\Users\he'ye\AppData\Roaming\Typora\typora-user-images\image-20250507083937307.png)

#### 3.解压缩看到目录功能正确，安装成功

![image-20250507084051636](C:\Users\he'ye\AppData\Roaming\Typora\typora-user-images\image-20250507084051636.png)

#### 4.ManualExample中有很多简单插桩程序的实列

![image-20250507084254678](C:\Users\he'ye\AppData\Roaming\Typora\typora-user-images\image-20250507084254678.png)

### （二）、编译inscount0

#### 1.打开inscount0.cpp

![image-20250507084350585](C:\Users\he'ye\AppData\Roaming\Typora\typora-user-images\image-20250507084350585.png)

#### 2.结构大体类似，其中定义全局变量，定义函数来计数，定义函数调用

![image-20250507084443838](C:\Users\he'ye\AppData\Roaming\Typora\typora-user-images\image-20250507084443838.png)

![image-20250507084659436](C:\Users\he'ye\AppData\Roaming\Typora\typora-user-images\image-20250507084659436.png)

#### 3.打开终端输入指令make inscount0.test TARGET=intel64进行编译

![image-20250507084937542](C:\Users\he'ye\AppData\Roaming\Typora\typora-user-images\image-20250507084937542.png)

#### 4.产生pintool的动态链接库

![image-20250507085039477](C:\Users\he'ye\AppData\Roaming\Typora\typora-user-images\image-20250507085039477.png)

### （三）、编译malloctrace

#### 1.打开malloctrace.cpp

![image-20250507085732038](C:\Users\he'ye\AppData\Roaming\Typora\typora-user-images\image-20250507085732038.png)

#### 2.终端执行make malloctrace.test TARGET=intel64

![image-20250507090003180](C:\Users\he'ye\AppData\Roaming\Typora\typora-user-images\image-20250507090003180.png)

#### 3.得到动态链接库

![image-20250507090053405](C:\Users\he'ye\AppData\Roaming\Typora\typora-user-images\image-20250507090053405.png)

### （四）、testCPP插桩

#### 1.新建文件夹testCPP，创建c程序first_cpp

![image-20250507091014064](C:\Users\he'ye\AppData\Roaming\Typora\typora-user-images\image-20250507091014064.png)

#### 2.终端输入gcc -o First first_cpp.c来编译

![image-20250507091234705](C:\Users\he'ye\AppData\Roaming\Typora\typora-user-images\image-20250507091234705.png)

#### 3.先设置pin路径后，执行./pin -t ./source/tools/ManualExamples/obj-intel64/inscount0.so -- ../testCPP/First   

![image-20250507092534171](C:\Users\he'ye\AppData\Roaming\Typora\typora-user-images\image-20250507092534171.png)

#### 4.运行后产生输出文件inscount.out

![image-20250507092600109](C:\Users\he'ye\AppData\Roaming\Typora\typora-user-images\image-20250507092600109.png)

#### 5.它会记录状态和类型，输出count 191523

![image-20250507092708649](C:\Users\he'ye\AppData\Roaming\Typora\typora-user-images\image-20250507092708649.png)

### （五）、复现malloctrace

#### 1.可以在inscount中修改Instruction执行新功能

![image-20250507101941171](C:\Users\he'ye\AppData\Roaming\Typora\typora-user-images\image-20250507101941171.png)

#### 2.之前编译的结果

![image-20250507093148689](C:\Users\he'ye\AppData\Roaming\Typora\typora-user-images\image-20250507093148689.png)

#### 3.用malloctrace进行插桩实验

![image-20250507104032537](C:\Users\he'ye\AppData\Roaming\Typora\typora-user-images\image-20250507104032537.png)

#### 4.打开malloctrace.out

![image-20250507104110352](C:\Users\he'ye\AppData\Roaming\Typora\typora-user-images\image-20250507104110352.png)

## 三、实验理解

### （一）、Pin插桩工具的核心步骤

#### 1.编写 Pin 工具程序：

创建一个新的 C++ 源文件，包含必要的 Pin 头文件，如   pin.H  。

#### 2.初始化 Pin 工具：

在   main   函数中，初始化 Pin 工具并设置回调函数，使用   PIN_InitSymbols()   初始化符号表。

#### 3.设置函数插桩：

使用   RTN_Open()   打开   malloc   和   free   函数的 RTN（可重定向的函数），并使用   RTN_InsertCall()   在这些函数中插入调用，设置插桩回调。

#### 4.实现插桩回调：

编写回调函数，这些函数将在调用   malloc   和   free   时被触发。在回调函数中，使用   ARG0  、  ARG1   等宏获取函数的输入参数，使用   RTN_ReturnValue()   获取函数的返回值。

### （二）、相关API

#### 1.PIN_InitSymbols()  ：

初始化符号表。

#### 2.RTN_Open()  ：

打开一个函数的 RTN。

#### 3.RTN_InsertCall()  ：

在函数中插入调用。

#### 4.ARG0, ARG1   等：

获取函数参数。

#### 5.RTN_ReturnValue()  ：

获取函数的返回值。

#### 6.RTN_Close()  ：

关闭 RTN。

### （三）、关注malloc和free函数的输入输出信息。

在   malloc   调用时可以记录请求的内存大小和返回的内存地址，在   free   调用时可以记录释放的内存地址。

malloc   函数用于在程序运行时请求分配指定大小的内存块，其原型为   void* malloc(size_t size)  ，其中   size   参数表示请求分配的内存大小（以字节为单位）。如果内存分配成功，  malloc   返回一个指向分配内存块起始地址的指针，该内存块已被清零；如果分配失败，则返回   NULL  。返回的内存必须通过   free   或   realloc   函数释放，以避免内存泄漏。

free   函数用于释放之前通过   malloc  、  calloc   或   realloc   分配的内存块，其原型为   void free(void* ptr)  ，其中   ptr   参数是指向要释放的内存块的指针。如果   ptr   是   NULL  ，则调用   free   没有效果，这是一种安全检查。释放内存后，指针   ptr   变得无效，不应再被使用，除非它再次被分配内存。多次释放同一个内存地址或释放未分配的内存地址会导致未定义行为，可能是程序崩溃或数据损坏。

## 四、心得体会

通过实验，我对Pin工具的程序插桩技术有了更深入的理解。实验中，我成功安装并使用了Pin工具来监控`malloc`和`free`函数的调用，这让我体会到了动态分析工具的强大功能。

实验过程包括安装Pin、编写和编译插桩程序、以及运行插桩程序来收集内存分配信息。我学会了如何设置Pin工具的回调函数来捕获`malloc`和`free`的输入输出信息，这对于分析程序的内存使用情况非常有用。

通过这次实验，我认识到了合理管理内存的重要性，并掌握了一种有效的工具来帮助检测内存泄漏和其它内存相关的问题。这不仅增强了我的软件安全知识，也为我未来的开发和调试工作提供了一个有用的技能。

